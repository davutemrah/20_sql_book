[["index.html", "SQL BOOK Acknowledgement", " SQL BOOK Davut Ayan 2024-08-30 Acknowledgement These notes have been compiled from open-source materials. Please note that the functions described may or may not work across different SQL engines or platforms. "],["joins.html", "Chapter 1 joins 1.1 joining 1.2 Set Operations", " Chapter 1 joins 1.1 joining 1.2 Set Operations Summary: UNION: Combines two result sets, removing duplicates. UNION ALL: Combines two result sets, keeping all duplicates. INTERSECT: Returns only the common rows between two result sets. MINUS/EXCEPT: Returns rows from the first result set that are not present in the second. 1.2.1 UNION Operator Combines the result sets of two or more SELECT statements, removing duplicate rows from the result set. SELECT &#39;XYZ&#39; AS AUDIENCE_NAME, COUNT(*) AS ID_COUNT FROM AUDIENCE_TABLE_1 UNION SELECT &#39;ABC&#39; AS AUDIENCE_NAME, COUNT(*) AS ID_COUNT FROM AUDIENCE_TABLE_2 Key Points: Duplicate Removal: UNION automatically removes duplicate rows. Column Alignment: The number and data types of the columns in each SELECT statement must be the same. Order: The order of rows from the individual queries is not guaranteed unless you use an ORDER BY clause in the final result. 1.2.2 UNION ALL Operator Combines the result sets of two or more SELECT statements, including all duplicate rows. SELECT first_name FROM employees UNION ALL SELECT first_name FROM clients; Key Points: Includes Duplicates: UNION ALL keeps all duplicate rows in the final result set. Performance: UNION ALL is generally faster than UNION Column Alignment: The columns must match in number and data type. 1.2.3 INTERSECT Operator Returns only the rows that are common to both SELECT queries (i.e., the intersection of the result sets). SELECT first_name FROM employees INTERSECT SELECT first_name FROM clients; Key Points: Common Rows Only: INTERSECT returns only rows that appear in both result sets. Duplicate Removal: Duplicates are removed within each individual result set before the intersection is determined. Column Alignment: The columns must match in number and data type. 1.2.4 MINUS (or EXCEPT) Operator Returns the rows from the first SELECT query that are not present in the second SELECT query. SELECT column_name(s) FROM table1 MINUS SELECT column_name(s) FROM table2; Key Points: Unique Rows Only: MINUS returns only the rows that are unique to the first result set. Duplicate Removal: Duplicates are removed from the first result set before subtraction. Column Alignment: The columns must match in number and data type. "],["basics.html", "Chapter 2 Basics 2.1 Order of Execution", " Chapter 2 Basics 2.1 Order of Execution FROM clause SQL begins by identifying and combining all relevant data from the specified tables. This includes any joins or subqueries. The FROM clause defines the data source and sets the foundation for the rest of the query. JOIN clause If there are any JOIN clauses, SQL processes them immediately after identifying the tables in the FROM clause. The joining of tables determines which rows from the combined tables are considered for further steps. WHERE clause After combining tables, SQL applies the WHERE clause to filter out rows that do not meet the criteria. The result is a reduced dataset that satisfies the condition(s). GROUP BY clause SQL groups the filtered rows based on the columns specified in the GROUP BY clause. This is necessary for aggregate functions like COUNT, SUM, AVG, etc. HAVING or QUALIFY clause After the GROUP BY clause, SQL applies the HAVING clause to filter the grouped results. Unlike WHERE, which filters rows before grouping, HAVING filters groups after they have been formed. The window functions like RANK() are executed before filtering by QUALIFY. The QUALIFY clause then filters based on the results of these window functions. SELECT After QUALIFY: The SELECT clause is applied last, selecting the columns from the result set after the filtering is done by QUALIFY. SELECT clause SQL evaluates the SELECT clause after all filtering, grouping, and having conditions have been applied. It determines which columns or expressions are included in the final output. DISTINCT clause SQL applies the DISTINCT clause after the SELECT clause, ensuring that only unique rows are returned. ORDER BY clause SQL orders the final result set according to the columns specified in the ORDER BY clause. This is the last step in query execution before the result set is returned. LIMIT - OFFSET - TOP SQL applies these clauses after all other operations have been completed. LIMIT defines how many rows to return, while OFFSET skips a specified number of rows. "],["creatind-tables.html", "Chapter 3 Creatind Tables 3.1 Date Functions", " Chapter 3 Creatind Tables CREATE OR REPLACE TABLE ABCD_TABLE AS SELECT * FROM TABLE_1 3.1 Date Functions ADDDATE(\"2017-06-15\", INTERVAL 10 DAY): add date adding 10 days to given date CURRENT_DATE() : return current date DATE(\"2017-06-15\") : extract date part DATEDIFF(END_DATE, START_DATE) : returns difference in days DATE_ADD(\"2017-06-15\", INTERVAL 10 DAY) : add date adding 10 days to given date DAY(\"2017-06-15\") : Return the day of the month for a date: DAYNAME(\"2017-06-15\") : Return the weekday name for a date: HOUR(\"2017-06-20 09:34:00\") : Return the hour part of a datetime: MONTH(\"2017-06-15\") : Return the month part of a date: SUBDATE(\"2017-06-15\", INTERVAL 10 DAY) : Subtract 10 days from a date and return the date WEEK(\"2017-10-25\") : Return the week number for a date: YEAR(\"2017-06-15\") : Return the year part of a date: "],["filtering.html", "Chapter 4 FILTERING 4.1 Wildcards 4.2 DISTINCT keyword 4.3 Advanced Filtering", " Chapter 4 FILTERING LIKE: Filters results based on a pattern match within a string column. LIKE ANY: Filters results based on a pattern match against any of a list of patterns. IN: Filters results where a column’s value matches any value in a list of values. NOT IN: Filters results where a column’s value does not match any value in a list of values. BETWEEN: Filters results where a column’s value falls within a specified range (inclusive). IS NULL and IS NOT NULL: Filters results based on whether a column’s value is NULL or not NULL. =and != (or &lt;&gt;): Filters results for exact matches or non-matches. ILIKE and ILIKE ANY: perform pattern matching without worrying about the case (upper or lower) of the letters in the string. SELECT TOP 5 * FROM employees WHERE NAME LIKE &#39;A%B.&#39; AND LAST_NAME LIKE ANY (&#39;ASD&#39;, &#39;%A&#39;, &#39;V_&#39;) AND CITY IN (&#39;CHICAGO&#39;, &#39;LAWRENCE&#39;) AND CITY IN (SELECT * FROM CITY_TABLE) AND STATE NOT IN (&#39;TEXAS&#39;) AND SALARY BETWEEN 100 AND 10000 AND DEPARTMENT IS NOT NULL AND SALARY &gt; 1000 AND NAME &lt;&gt; &#39;DAVID&#39; AND NAME ILIKE `david&#39; AND LOWER(NAME) LIKE &#39;david&#39; -- for those ILIKE is not supported 4.1 Wildcards %: Matches any sequence of characters (including zero characters). _: Matches any single character. [] (SQL Server): Matches any single character within the specified set or range. [^] (SQL Server): Matches any single character not in the specified set or range. - (SQL Server): Defines a range of characters within square brackets. SELECT TOP 5 * FROM employees WHERE NAME LIKE &#39;A%B&#39; -- starts with A and ends with B AND NAME LIKE &#39;ALE_&#39; -- 4 character and starts with ALE AND NAME LIKE &#39;[JM]ason&#39; -- jason or mason AND NAME LIKE &#39;[^JM]ason&#39; -- not jason or mason AND NAME LIKE &#39;[A-D]%&#39; -- all names that start with any letter between &#39;A&#39; and &#39;D&#39; 4.2 DISTINCT keyword When DISTINCT is applied to a single column, it filters out duplicate values in that specific column, returning only unique values for that column. Single Column: Returns unique values for that column. Multiple Columns: Returns unique combinations of the specified columns. 4.3 Advanced Filtering 4.3.1 HAVING Clause The HAVING clause is used to filter records that work on aggregated data, as opposed to the WHERE clause which filters rows before any aggregation is applied. Use HAVING when you need to filter groups after applying GROUP BY and aggregate functions (like SUM, COUNT, AVG, etc.). Example: This query returns departments with more than 10 employees. SELECT department, COUNT(employee_id) AS num_employees FROM employees GROUP BY department HAVING COUNT(employee_id) &gt; 10 4.3.2 QUALIFY Clause The QUALIFY clause filters the result set after window functions have been applied. It’s particularly useful when you want to filter results based on the output of window functions like ROW_NUMBER, RANK, or DENSE_RANK. Use QUALIFY when you need to apply filtering conditions after using window functions, making it easier to handle complex queries involving ranking or ordering within groups. SELECT employee_id, department, RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS salary_rank FROM employees QUALIFY salary_rank = 1; "],["most-used-functions.html", "Chapter 5 MOST USED FUNCTIONS 5.1 string functions 5.2 Aggregate Functions: 5.3 Non-Aggregate Functions: 5.4 Window Functions 5.5 Functions comparing columns: 5.6 Some Advanced Functions", " Chapter 5 MOST USED FUNCTIONS 5.1 string functions LENGTH(): Returns the length of the string in the column. LOWER() and UPPER(): Converts all characters in the string column to lowercase (LOWER) or uppercase (UPPER). TRIM(): Removes leading and trailing spaces from the string in the column. SUBSTR(string, start_position, [length]): Extracts a substring from a string, starting at a specified position, and optionally for a specified number of characters. LEFT(column, 5): Extracts a specified number of characters from the left (beginning) of a string. CONCAT(col1, col2): Concatenates two or more strings together. SELECT LENGTH(first_name) AS lenght_of_first_name, LOWER(first_name) AS lower_case, UPPER(first_name) AS upper_case, TRIM(first_name) AS NAME, SUBSTR(first_name, 1, 5) AS NAME_5_CHAR, SUBSTR(last_name, 3) AS remaining_name, LEFT(first_name, 3) AS short_name, CONCAT(first_name, &#39;_&#39;, last_name) AS FULL_NAME FROM employees; 5.2 Aggregate Functions: These functions can also serve as window functions. AVG() : Computes the average value of a set of rows within the window or partition or across all rows SELECT AVG(SALARY) AS AVERAGE_SALARY, AVG(SALARY) OVER (PARTITION BY DEPT) AS AVG_DEPT_SALARY FROM employees; COUNT() : Counts the number of rows in the window (partition) or across the entire result set. SELECT COUNT(DISTINCT ID) AS DIISTINCT_ID_COUNT, COUNT(EMP_ID) OVER (PARTITION BY DEPARTMENT) AS DEPT_EMP_COUNT FROM employees; SUM() : Computes the sum of values within the window (partition) or across the entire result set. SELECT SUM(SALARY) AS SALARY_TOTAL, SUM(SALARY) OVER (PARTITION BY DEPT) AS DEPT_SALARY_TOTAL FROM employees; MIN() and MAX(): Returns the minimum or maximum value within the window or partition. SELECT MIN(SALARY) AS MIN_SALARY, MAX(SALARY) AS MAX_SALARY, MIN(SALARY) OVER (PARTITION BY DEPT) AS MIN_DEPT_SALARY, MAX(SALARY) OVER (PARTITION BY DEPT) AS MAX_DEPT_SALARY FROM employees; 5.3 Non-Aggregate Functions: ABS() : Returns the absolute value of each number in the column. CEIL() or CEILING() : Returns the smallest integer value greater than or equal to each number in the column. FLOOR() : Returns the largest integer value less than or equal to each number in the column. ROUND(col, 2): Rounds the values in cola to 2 decimal places. POWER(col, n): Returns the value of the column raised to the power n. SQRT(): Returns the square root of each number in the column. EXP(): Returns e raised to the power of each number in the column. LOG(): Returns the natural logarithm of each number in the column. TRUNCATE(col, n): Truncates (cuts off) the values in the column to n decimal places, without rounding. 5.4 Window Functions ROW_NUMBER(): Assigns a unique sequential integer to rows within a partition of a result set, starting at 1 for the first row in each partition. This assigns a unique rank based on the salary, with the highest salary getting rank 1. SELECT ROW_NUMBER() OVER (PARTITION BY XYZ ORDER BY salary DESC) AS rank FROM employees; RANK(): Assigns a rank to each row within a partition of a result set, with the same rank assigned to rows with equal values. The next distinct value(s) are given a rank that skips numbers if there are ties. If two employees have the same salary, they will receive the same rank, and the next rank will skip accordingly (e.g., 1, 2, 2, 4). SELECT RANK() OVER (PARTITION BY XYZ ORDER BY salary DESC) AS rank FROM employees; DENSE_RANK(): Similar to RANK(), but it does not skip ranks after ties. If two employees have the same salary, they will receive the same rank, but the next rank will continue sequentially (e.g., 1, 2, 2, 3). SELECT DENSE_RANK() OVER (PARTITION BY XYZ ORDER BY salary DESC) AS rank FROM employees; NTILE(n): Divides the rows in an ordered partition into n buckets or groups, and assigns a bucket number to each row. This is useful for distributing rows into quantiles. This divides the employees into four quartiles based on their salary. SELECT employee_id, salary, NTILE(4) OVER (ORDER BY salary DESC) AS quartile FROM employees;   LAG() and LEAD(): Accesses data from previous (LAG) or subsequent (LEAD) rows in the result set, without using a self-join. SELECT LAG(salary, 1) OVER (ORDER BY salary DESC) AS previous_salary, LEAD(salary, 1) OVER (ORDER BY salary DESC) AS next_salary FROM employees; FIRST_VALUE() and LAST_VALUE(): Returns the first or last value in a window or partition. SELECT FIRST_VALUE(salary) OVER (ORDER BY salary DESC) AS HIGHEST_SALARY LAST_VALUE(salary) OVER (ORDER BY salary DESC) AS LOWEST_SALARY FROM employees; PERCENT_RANK(): Calculates the relative rank of the current row within a partition, expressed as a percentage. SELECT PERCENT_RANK() OVER (ORDER BY salary DESC) AS percentile_rank FROM employees; 5.5 Functions comparing columns: These functions all operate on a per-row basis, evaluating or combining values from multiple columns within the same row. GREATEST(cola, colb, 0): Returns the greatest (largest) value from the list of columns for each row. LEAST(cola, colb, 0): Returns the smallest value among the list of arguments within a single row. COALESCE(cola, colb, 0) : Returns the first non-null value in the column, or the default_value if all are null. SELECT GREATEST(SALARY_2000, SALARY_2010) AS GREATEST_SALARY, LEAST(SALARY_2000, SALARY_2010) AS LEAST_SALARY, COALESCE(SALARY_2000, SALARY_2010) as SALARY FROM employees; 5.6 Some Advanced Functions 5.6.1 LISTAGG concatenates values from multiple rows into a single string. This query lists all medications in each ID, ordered by their name of medications, with the names concatenated into a single string. SELECT ID, LISTAGG(DISTINCT MEDICATIONS, &#39;, &#39;) WITHIN GROUP (ORDER BY MEDICATIONS) AS MED_ARRAY FROM table_name GROUP BY ID 5.6.2 LATERAL This SQL query involves a few advanced concepts, including the use of the LATERAL join and the FLATTEN function, which are specific to certain SQL platforms like Snowflake. Here’s a breakdown of the query: ID_ARRAY: LIST OF IDS IN EACH ROW FLATTEN function is used to “unpack” or “expand” the ID_ARRAY column into individual elements. Essentially, it takes an array and returns each element in the array as a separate row. SELECT F.MY_ID::VARCHAR AS MY_ID FROM TABLE_1 A, LATERAL FLATTEN(A.ID_ARRAY) AS F 5.6.3 UPDATE you want to update the salary of an employee with an EmployeeID of 5 to $75,000. You would write: UPDATE MY_TABLE SET Salary = 75000, JobTitle = &#39;Senior Analyst&#39; WHERE EmployeeID = 5; 5.6.4 ALTER DROP COLUMN “MiddleName” FROM Employees TABLE ALTER TABLE Employees DROP COLUMN MiddleName; 5.6.5 DELETE ROWS This will delete all rows but keep data structure TRUNCATE TABLE table_name; This will delete all rows but keep data structure. And also log row deletion. DELETE FROM table_name; 5.6.6 INSERT You can now insert new data into the table: INSERT INTO table_name (column1, column2, ...) SELECT column1, column2, ... FROM source_table WHERE condition; INSERT INTO table_name SELECT * FROM source_table "],["adhoc-solutions.html", "Chapter 6 Adhoc solutions 6.1 DATA QA EFFORTS 6.2 Balancing Weights 6.3 Weighted Sampling 6.4 Demographic Distribution 6.5 Risky Projects 6.6 How many users have applied to the same companies they have applied before the past year?", " Chapter 6 Adhoc solutions 6.1 DATA QA EFFORTS 6.1.1 COUNTS SELECT COUNT(*) AS NUM_ROWS, COUNT(DISTINCT ID) AS DISTINCT_ID_COUNT, COUNT(DISTINCT HHID) AS DISTINCT_HHID_COUNT, COUNT_IF(ID IS NOT NULL) AS VALID_ID_COUNT, COUNT_IF(HHID IS NOT NULL) AS VALID_HHID_COUNT FROM DATA_TABLE 6.2 Balancing Weights WITH CENSUS AS ( SELECT AGE_BIN, INCOME_BIN, GENDER_BIN, SUM(PERWT) AS TARGET, ROW_NUMBER() OVER(ORDER BY AGE_BIN, INCOME_BIN, GENDER_BIN) AS SEGMENTS FROM CENSUS GROUP BY AGE_BIN, INCOME_BIN, GENDER_BIN ), ID_TABLE AS ( SELECT DISTINCT ID, AGE_BIN, INCOME_BIN, GENDER_BIN, COUNT(DISTINCT ID) OVER()::DOUBLE PRECISION AS SAMPLE_SIZE FROM POPULATION_TABLE WHERE AGE_BIN IS NOT NULL AND INCOME_BIN IS NOT NULL AND GENDER_BIN IS NOT NULL ), FINAL AS ( SELECT ID, AGE_BIN, INCOME_BIN, GENDER_BIN, B.SEGMENTS, B.TARGET*(SAMPLE_SIZE/B.TOTAL_POP) AS NORMALIZED_TARGETS, COUNT(*) OVER(PARTITION BY B.SEGMENTS ORDER BY NULL) AS SEGMENT_COUNTS, NORMALIZED_TARGETS/SEGMENT_COUNTS AS WEIGHT, B.TARGET_COUNTS/SEGMENT_COUNTS AS POP_WEIGHT FROM ID_TABLE A INNER JOIN CENSUS B ON A.AGE_BIN = B.AGE_BIN AND A.INCOME_BIN = B.INCOME_BIN AND C.GENDER_BIN = B.GENDER_BIN ORDER BY SEGMENTS ) SELECT ID, WEIGHT, POP_WEIGHT FROM FINAL ORDER BY ID 6.3 Weighted Sampling 6.3.1 Solution WITH ONE AS ( SELECT 1 AS CHILDCARE, 0.17 AS CHILD UNION ALL SELECT 0 AS CHILDCARE, 0.83 AS CHILD ), TWO AS ( SELECT 1 AS SENIOR_CARE, 0.3 AS SENIOR UNION ALL SELECT 0 AS SENIOR_CARE, 0.7 AS SENIOR ), THREE AS ( SELECT 1 AS TUTORING, 0.22 AS TUTOR UNION ALL SELECT 0 AS TUTORING, 0.78 AS TUTOR ), TARGET_COUNTS AS ( SELECT CHILDCARE, SENIOR_CARE, TUTORING, ROW_NUMBER() OVER (ORDER BY CHILDCARE, SENIOR_CARE, TUTORING) AS SEGMENTS, ROUND(CHILD*SENIOR*TUTOR*6000000) AS TARGET_COUNT FROM ONE, TWO, THREE ) SELECT A.*, COUNT(*) OVER(PARTITION BY B.SEGMENTS ORDER BY NULL) AS ID_COUNTS, (B.TARGET_COUNT/BLU_COUNTS) AS WEIGHT FROM TABLE_AUDIENCE A INNER JOIN TARGET_COUNTS B ON A.CHILD_CARE=B.CHILD_CARE AND A.SENIOR_CARE=B.SENIOR_CARE AND A.TUTORING=B.TUTORING ORDER BY SEGMENTS 6.4 Demographic Distribution Assuming TABLE_POPULATION is distinct on ID column. SELECT AGE_CATEGORY, COUNT(ID) AS RAW_COUNT, SUM(COUNT(ID)) OVER() AS TOTAL_COUNTS, COUNT(ID) / SUM(COUNT(ID)) OVER() AS PCT_DIST, SUM(WEIGHT) AS WEIGHTED_COUNT, SUM(SUM(WEIGHT)) OVER() AS WEIGHTED_TOTAL_COUNTS, SUM(WEIGHT) / SUM(SUM(WEIGHT)) OVER() AS WEIGHTED_PCT_DIST FROM TABLE_POPULATION GROUP BY AGE_CATEGORY 6.5 Risky Projects Identify projects that are at risk for going overbudget. A project is considered to be overbudget if the cost of all employees assigned to the project is greater than the budget of the project. You’ll need to prorate the cost of the employees to the duration of the project. For example, if the budget for a project that takes half a year to complete is $10K, then the total half-year salary of all employees assigned to the project should not exceed $10K. Salary is defined on a yearly basis, so be careful how to calculate salaries for the projects that last less or more than one year. Output a list of projects that are overbudget with their project name, project budget, and prorated total employee expense (rounded to the next dollar amount). HINT: to make it simpler, consider that all years have 365 days. You don’t need to think about the leap years. Tables: linkedin_projects, linkedin_emp_projects, linkedin_employees 6.5.1 tables table: linkedin_projects id–int, title–varchar budget–int start_date–datetime end_date–datetime table: linkedin_emp_projects emp_id–int project_id– table: linkedin_employees id–int, first_name   last_name   salary–int   6.5.2 SOLUTION 1 DURATION YEAR 1 IS CALCULATED SEPARATELY WILL CAUSE PROBLEMS, BECAUSE IT IS NOT COSTLY TO KEEP IT ACCURATE TO DECIMAL POINTS WITH PROJECT_DURATION AS ( SELECT DISTINCT id, DATEDIFF(end_date, start_date)/365.0 AS DURATION_YR FROM linkedin_projects ORDER BY DURATION_YR DESC ), COST AS ( SELECT A.project_id, SUM(B.SALARY * C.DURATION_YR) AS PROJECT_COST FROM linkedin_emp_projects A INNER JOIN linkedin_employees B ON A.EMP_ID = B.ID INNER JOIN PROJECT_DURATION C ON A.project_id = C.ID GROUP BY A.project_id ) SELECT A.TITLE, A.BUDGET, CEILING(B.PROJECT_COST) AS PROJECT_COST FROM linkedin_projects A INNER JOIN COST B ON A.ID = B.project_id WHERE A.BUDGET &lt; CEILING(B.PROJECT_COST) ORDER BY TITLE ASC; 6.5.3 SOULTION 2 BETTER SOLUTION SELECT A.TITLE, A.BUDGET, CEILING(SUM(B.SALARY) * DATEDIFF(A.end_date, A.start_date) / 365.0) AS PROJECT_COST FROM linkedin_projects A LEFT JOIN linkedin_emp_projects C ON A.ID = C.project_id LEFT JOIN linkedin_employees B ON C.EMP_ID = B.ID GROUP BY A.ID HAVING A.BUDGET &lt; PROJECT_COST; 6.6 How many users have applied to the same companies they have applied before the past year? WITH UserApplications AS ( SELECT user_id, company_id, application_date, ROW_NUMBER() OVER (PARTITION BY user_id, company_id ORDER BY application_date) AS application_order FROM applications WHERE application_date &gt;= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) ) SELECT user_id, COUNT(DISTINCT company_id) AS companies_applied_again FROM UserApplications WHERE application_order &gt; 1 GROUP BYuser_id HAVING COUNT(DISTINCT company_id) &gt; 0; "],["coding-can-you-provide-the-solutions-to-a-using-python-or-r.html", "Chapter 7 [Coding] Can you provide the solutions to (A) using Python or R?", " Chapter 7 [Coding] Can you provide the solutions to (A) using Python or R? "],["sample-solutions.html", "Chapter 8 Sample Solutions 8.1 Datalemur 20 Solved SQL", " Chapter 8 Sample Solutions 8.1 Datalemur 20 Solved SQL 8.1.1 Repeated transactions Sometimes, payment transactions are repeated by accident; it could be due to user error, API failure or a retry error that causes a credit card to be charged twice. Using the transactions table, identify any payments made at the same merchant with the same credit card for the same amount within 10 minutes of each other. Count such repeated payments. Assumptions: The first transaction of such payments should not be counted as a repeated payment. This means, if there are two transactions performed by a merchant with the same credit card and for the same amount within 10 minutes, there will only be 1 repeated payment. Solution for PostgreSQL 14 SELECT COUNT(DISTINCT A.transaction_id) AS PAYMENT_COUNT FROM transactions A INNER JOIN transactions B ON A.merchant_id=B.merchant_id AND A.credit_card_id=B.credit_card_id AND A.AMOUNT=B.AMOUNT WHERE EXTRACT(EPOCH FROM (A.transaction_timestamp - B.transaction_timestamp))/60 &gt; 0 AND EXTRACT(EPOCH FROM (A.transaction_timestamp - B.transaction_timestamp))/60 &lt;= 10 Alternative solution in SNOWFLAKE SELECT COUNT(DISTINCT A.transaction_id) AS PAYMENT_COUNT FROM transactions A INNER JOIN transactions B ON A.merchant_id = B.merchant_id AND A.credit_card_id = B.credit_card_id AND A.AMOUNT = B.AMOUNT AND A.transaction_id != B.transaction_id WHERE DATEDIFF(minute, B.transaction_timestamp, A.transaction_timestamp) &gt; 0 AND DATEDIFF(minute, B.transaction_timestamp, A.transaction_timestamp) &lt;= 10; Using LAG() window function WITH payments AS ( SELECT merchant_id, EXTRACT(EPOCH FROM transaction_timestamp - LAG(transaction_timestamp) OVER( PARTITION BY merchant_id, credit_card_id, amount ORDER BY transaction_timestamp) )/60 AS minute_difference FROM transactions ) SELECT COUNT(merchant_id) AS payment_count FROM payments WHERE minute_difference &lt;= 10; 8.1.2 Describe how recursive queries work in SQL. Provide an example scenario where a recursive query would be beneficial. Recursive queries in SQL enable iteration over hierarchical data structures like organizational charts, bill-of-materials, or nested comments. For example, you could use a recursive query to traverse a hierarchical data structure and retrieve all descendants of a specific node. Scenario: Organizational Hierarchy Reporting Imagine you have an employee table in a database that stores information about employees and their reporting structure in a large company. The table includes an EmployeeID, EmployeeName, and ManagerID, where ManagerID is a reference to another EmployeeID, indicating who the manager is for that employee. Objective: You need to generate a report that lists all employees under a specific manager, including all levels of the hierarchy (i.e., the manager’s direct reports, the direct reports of those direct reports, and so on). CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, EmployeeName VARCHAR(100), ManagerID INT -- This references EmployeeID in the same table ); Sample Data INSERT INTO Employees (EmployeeID, EmployeeName, ManagerID) VALUES (1, &#39;Alice&#39;, NULL), -- Alice is the CEO, no manager (2, &#39;Bob&#39;, 1), -- Bob reports to Alice (3, &#39;Charlie&#39;, 2), -- Charlie reports to Bob (4, &#39;David&#39;, 2), -- David reports to Bob (5, &#39;Eve&#39;, 3), -- Eve reports to Charlie (6, &#39;Frank&#39;, 3); -- Frank reports to Charlie 8.1.2.1 Recursive Query Example: To retrieve the entire hierarchy under Bob (EmployeeID = 2): WITH RECURSIVE EmployeeHierarchy AS ( -- Anchor member: Start with the manager (Bob) SELECT EmployeeID, EmployeeName, ManagerID FROM Employees WHERE EmployeeID = 2 UNION ALL -- Recursive member: Retrieve all employees who report to the current level of employees SELECT e.EmployeeID, e.EmployeeName, e.ManagerID FROM Employees e INNER JOIN EmployeeHierarchy eh ON e.ManagerID = eh.EmployeeID ) SELECT EmployeeID, EmployeeName, ManagerID FROM EmployeeHierarchy; Why Use a Recursive Query Here? The recursive query effectively traverses the hierarchy and retrieves all descendants of a specific manager. This approach is scalable and adaptable to varying levels of hierarchy depth, which would be challenging to achieve with a non-recursive query. 8.1.3 Median Google Search Frequency Google’s marketing team is making a Superbowl commercial and needs a simple statistic to put on their TV ad: the median number of searches a person made last year. However, at Google scale, querying the 2 trillion searches is too costly. Luckily, you have access to the summary table which tells you the number of searches made last year and how many Google users fall into that bucket. Write a query to report the median of searches made by a user. Round the median to one decimal point. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
