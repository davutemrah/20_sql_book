[["index.html", "SQL BOOK Acknowledgement", " SQL BOOK Davut Ayan 2024-08-21 Acknowledgement These notes have been compiled from open-source materials. Please note that the functions described may or may not work across different SQL engines or platforms. "],["joins.html", "Chapter 1 joins 1.1 joining 1.2 Set Operations", " Chapter 1 joins 1.1 joining 1.2 Set Operations Summary: UNION: Combines two result sets, removing duplicates. UNION ALL: Combines two result sets, keeping all duplicates. INTERSECT: Returns only the common rows between two result sets. MINUS/EXCEPT: Returns rows from the first result set that are not present in the second. 1.2.1 UNION Operator Combines the result sets of two or more SELECT statements, removing duplicate rows from the result set. SELECT &#39;XYZ&#39; AS AUDIENCE_NAME, COUNT(*) AS ID_COUNT FROM AUDIENCE_TABLE_1 UNION SELECT &#39;ABC&#39; AS AUDIENCE_NAME, COUNT(*) AS ID_COUNT FROM AUDIENCE_TABLE_2 Key Points: Duplicate Removal: UNION automatically removes duplicate rows. Column Alignment: The number and data types of the columns in each SELECT statement must be the same. Order: The order of rows from the individual queries is not guaranteed unless you use an ORDER BY clause in the final result. 1.2.2 UNION ALL Operator Combines the result sets of two or more SELECT statements, including all duplicate rows. SELECT first_name FROM employees UNION ALL SELECT first_name FROM clients; Key Points: Includes Duplicates: UNION ALL keeps all duplicate rows in the final result set. Performance: UNION ALL is generally faster than UNION Column Alignment: The columns must match in number and data type. 1.2.3 INTERSECT Operator Returns only the rows that are common to both SELECT queries (i.e., the intersection of the result sets). SELECT first_name FROM employees INTERSECT SELECT first_name FROM clients; Key Points: Common Rows Only: INTERSECT returns only rows that appear in both result sets. Duplicate Removal: Duplicates are removed within each individual result set before the intersection is determined. Column Alignment: The columns must match in number and data type. 1.2.4 MINUS (or EXCEPT) Operator Returns the rows from the first SELECT query that are not present in the second SELECT query. SELECT column_name(s) FROM table1 MINUS SELECT column_name(s) FROM table2; Key Points: Unique Rows Only: MINUS returns only the rows that are unique to the first result set. Duplicate Removal: Duplicates are removed from the first result set before subtraction. Column Alignment: The columns must match in number and data type. "],["basics.html", "Chapter 2 Basics 2.1 Order of Execution", " Chapter 2 Basics 2.1 Order of Execution FROM clause SQL begins by identifying and combining all relevant data from the specified tables. This includes any joins or subqueries. The FROM clause defines the data source and sets the foundation for the rest of the query. JOIN clause If there are any JOIN clauses, SQL processes them immediately after identifying the tables in the FROM clause. The joining of tables determines which rows from the combined tables are considered for further steps. WHERE clause After combining tables, SQL applies the WHERE clause to filter out rows that do not meet the criteria. The result is a reduced dataset that satisfies the condition(s). GROUP BY clause SQL groups the filtered rows based on the columns specified in the GROUP BY clause. This is necessary for aggregate functions like COUNT, SUM, AVG, etc. HAVING or QUALIFY clause After the GROUP BY clause, SQL applies the HAVING clause to filter the grouped results. Unlike WHERE, which filters rows before grouping, HAVING filters groups after they have been formed. The window functions like RANK() are executed before filtering by QUALIFY. The QUALIFY clause then filters based on the results of these window functions. SELECT After QUALIFY: The SELECT clause is applied last, selecting the columns from the result set after the filtering is done by QUALIFY. SELECT clause SQL evaluates the SELECT clause after all filtering, grouping, and having conditions have been applied. It determines which columns or expressions are included in the final output. DISTINCT clause SQL applies the DISTINCT clause after the SELECT clause, ensuring that only unique rows are returned. ORDER BY clause SQL orders the final result set according to the columns specified in the ORDER BY clause. This is the last step in query execution before the result set is returned. LIMIT - OFFSET - TOP SQL applies these clauses after all other operations have been completed. LIMIT defines how many rows to return, while OFFSET skips a specified number of rows. "],["creatind-tables.html", "Chapter 3 Creatind Tables", " Chapter 3 Creatind Tables CREATE OR REPLACE TABLE ABCD_TABLE AS SELECT * FROM TABLE_1 "],["filtering.html", "Chapter 4 FILTERING 4.1 Wildcards 4.2 DISTINCT keyword 4.3 Advanced Filtering", " Chapter 4 FILTERING LIKE: Filters results based on a pattern match within a string column. LIKE ANY: Filters results based on a pattern match against any of a list of patterns. IN: Filters results where a column’s value matches any value in a list of values. NOT IN: Filters results where a column’s value does not match any value in a list of values. BETWEEN: Filters results where a column’s value falls within a specified range (inclusive). IS NULL and IS NOT NULL: Filters results based on whether a column’s value is NULL or not NULL. =and != (or &lt;&gt;): Filters results for exact matches or non-matches. ILIKE and ILIKE ANY: perform pattern matching without worrying about the case (upper or lower) of the letters in the string. SELECT TOP 5 * FROM employees WHERE NAME LIKE &#39;A%B.&#39; AND LAST_NAME LIKE ANY (&#39;ASD&#39;, &#39;%A&#39;, &#39;V_&#39;) AND CITY IN (&#39;CHICAGO&#39;, &#39;LAWRENCE&#39;) AND CITY IN (SELECT * FROM CITY_TABLE) AND STATE NOT IN (&#39;TEXAS&#39;) AND SALARY BETWEEN 100 AND 10000 AND DEPARTMENT IS NOT NULL AND SALARY &gt; 1000 AND NAME &lt;&gt; &#39;DAVID&#39; AND NAME ILIKE `david&#39; AND LOWER(NAME) LIKE &#39;david&#39; -- for those ILIKE is not supported 4.1 Wildcards %: Matches any sequence of characters (including zero characters). _: Matches any single character. [] (SQL Server): Matches any single character within the specified set or range. [^] (SQL Server): Matches any single character not in the specified set or range. - (SQL Server): Defines a range of characters within square brackets. SELECT TOP 5 * FROM employees WHERE NAME LIKE &#39;A%B&#39; -- starts with A and ends with B AND NAME LIKE &#39;ALE_&#39; -- 4 character and starts with ALE AND NAME LIKE &#39;[JM]ason&#39; -- jason or mason AND NAME LIKE &#39;[^JM]ason&#39; -- not jason or mason AND NAME LIKE &#39;[A-D]%&#39; -- all names that start with any letter between &#39;A&#39; and &#39;D&#39; 4.2 DISTINCT keyword When DISTINCT is applied to a single column, it filters out duplicate values in that specific column, returning only unique values for that column. Single Column: Returns unique values for that column. Multiple Columns: Returns unique combinations of the specified columns. 4.3 Advanced Filtering 4.3.1 HAVING Clause The HAVING clause is used to filter records that work on aggregated data, as opposed to the WHERE clause which filters rows before any aggregation is applied. Use HAVING when you need to filter groups after applying GROUP BY and aggregate functions (like SUM, COUNT, AVG, etc.). Example: This query returns departments with more than 10 employees. SELECT department, COUNT(employee_id) AS num_employees FROM employees GROUP BY department HAVING COUNT(employee_id) &gt; 10 4.3.2 QUALIFY Clause The QUALIFY clause filters the result set after window functions have been applied. It’s particularly useful when you want to filter results based on the output of window functions like ROW_NUMBER, RANK, or DENSE_RANK. Use QUALIFY when you need to apply filtering conditions after using window functions, making it easier to handle complex queries involving ranking or ordering within groups. SELECT employee_id, department, RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS salary_rank FROM employees QUALIFY salary_rank = 1; "],["most-used-functions.html", "Chapter 5 MOST USED FUNCTIONS 5.1 string functions 5.2 Aggregate Functions: 5.3 Non-Aggregate Functions: 5.4 Window Functions 5.5 Functions comparing columns: 5.6 date functions 5.7 Some Advanced Functions", " Chapter 5 MOST USED FUNCTIONS 5.1 string functions LENGTH(): Returns the length of the string in the column. LOWER() and UPPER(): Converts all characters in the string column to lowercase (LOWER) or uppercase (UPPER). TRIM(): Removes leading and trailing spaces from the string in the column. SUBSTR(string, start_position, [length]): Extracts a substring from a string, starting at a specified position, and optionally for a specified number of characters. LEFT(column, 5): Extracts a specified number of characters from the left (beginning) of a string. CONCAT(col1, col2): Concatenates two or more strings together. SELECT LENGTH(first_name) AS lenght_of_first_name, LOWER(first_name) AS lower_case, UPPER(first_name) AS upper_case, TRIM(first_name) AS NAME, SUBSTR(first_name, 1, 5) AS NAME_5_CHAR, SUBSTR(last_name, 3) AS remaining_name, LEFT(first_name, 3) AS short_name, CONCAT(first_name, &#39;_&#39;, last_name) AS FULL_NAME FROM employees; 5.2 Aggregate Functions: These functions can also serve as window functions. AVG() : Computes the average value of a set of rows within the window or partition or across all rows SELECT AVG(SALARY) AS AVERAGE_SALARY, AVG(SALARY) OVER (PARTITION BY DEPT) AS AVG_DEPT_SALARY FROM employees; COUNT() : Counts the number of rows in the window (partition) or across the entire result set. SELECT COUNT(DISTINCT ID) AS DIISTINCT_ID_COUNT, COUNT(EMP_ID) OVER (PARTITION BY DEPARTMENT) AS DEPT_EMP_COUNT FROM employees; SUM() : Computes the sum of values within the window (partition) or across the entire result set. SELECT SUM(SALARY) AS SALARY_TOTAL, SUM(SALARY) OVER (PARTITION BY DEPT) AS DEPT_SALARY_TOTAL FROM employees; MIN() and MAX(): Returns the minimum or maximum value within the window or partition. SELECT MIN(SALARY) AS MIN_SALARY, MAX(SALARY) AS MAX_SALARY, MIN(SALARY) OVER (PARTITION BY DEPT) AS MIN_DEPT_SALARY, MAX(SALARY) OVER (PARTITION BY DEPT) AS MAX_DEPT_SALARY FROM employees; 5.3 Non-Aggregate Functions: ABS() : Returns the absolute value of each number in the column. CEIL() or CEILING() : Returns the smallest integer value greater than or equal to each number in the column. FLOOR() : Returns the largest integer value less than or equal to each number in the column. ROUND(col, 2): Rounds the values in cola to 2 decimal places. POWER(col, n): Returns the value of the column raised to the power n. SQRT(): Returns the square root of each number in the column. EXP(): Returns e raised to the power of each number in the column. LOG(): Returns the natural logarithm of each number in the column. TRUNCATE(col, n): Truncates (cuts off) the values in the column to n decimal places, without rounding. 5.4 Window Functions ROW_NUMBER(): Assigns a unique sequential integer to rows within a partition of a result set, starting at 1 for the first row in each partition. This assigns a unique rank based on the salary, with the highest salary getting rank 1. SELECT ROW_NUMBER() OVER (PARTITION BY XYZ ORDER BY salary DESC) AS rank FROM employees; RANK(): Assigns a rank to each row within a partition of a result set, with the same rank assigned to rows with equal values. The next distinct value(s) are given a rank that skips numbers if there are ties. If two employees have the same salary, they will receive the same rank, and the next rank will skip accordingly (e.g., 1, 2, 2, 4). SELECT RANK() OVER (PARTITION BY XYZ ORDER BY salary DESC) AS rank FROM employees; DENSE_RANK(): Similar to RANK(), but it does not skip ranks after ties. If two employees have the same salary, they will receive the same rank, but the next rank will continue sequentially (e.g., 1, 2, 2, 3). SELECT DENSE_RANK() OVER (PARTITION BY XYZ ORDER BY salary DESC) AS rank FROM employees; NTILE(n): Divides the rows in an ordered partition into n buckets or groups, and assigns a bucket number to each row. This is useful for distributing rows into quantiles. This divides the employees into four quartiles based on their salary. SELECT employee_id, salary, NTILE(4) OVER (ORDER BY salary DESC) AS quartile FROM employees;   LAG() and LEAD(): Accesses data from previous (LAG) or subsequent (LEAD) rows in the result set, without using a self-join. SELECT LAG(salary, 1) OVER (ORDER BY salary DESC) AS previous_salary, LEAD(salary, 1) OVER (ORDER BY salary DESC) AS next_salary FROM employees; FIRST_VALUE() and LAST_VALUE(): Returns the first or last value in a window or partition. SELECT FIRST_VALUE(salary) OVER (ORDER BY salary DESC) AS HIGHEST_SALARY LAST_VALUE(salary) OVER (ORDER BY salary DESC) AS LOWEST_SALARY FROM employees; PERCENT_RANK(): Calculates the relative rank of the current row within a partition, expressed as a percentage. SELECT PERCENT_RANK() OVER (ORDER BY salary DESC) AS percentile_rank FROM employees; 5.5 Functions comparing columns: These functions all operate on a per-row basis, evaluating or combining values from multiple columns within the same row. GREATEST(cola, colb, 0): Returns the greatest (largest) value from the list of columns for each row. LEAST(cola, colb, 0): Returns the smallest value among the list of arguments within a single row. COALESCE(cola, colb, 0) : Returns the first non-null value in the column, or the default_value if all are null. SELECT GREATEST(SALARY_2000, SALARY_2010) AS GREATEST_SALARY, LEAST(SALARY_2000, SALARY_2010) AS LEAST_SALARY, COALESCE(SALARY_2000, SALARY_2010) as SALARY FROM employees; 5.6 date functions ADDDATE(\"2017-06-15\", INTERVAL 10 DAY): add date adding 10 days to given date CURRENT_DATE() : return current date DATE(\"2017-06-15\") : extract date part DATEDIFF(END_DATE, START_DATE) : returns difference in days DATE_ADD(\"2017-06-15\", INTERVAL 10 DAY) : add date adding 10 days to given date DAY(\"2017-06-15\") : Return the day of the month for a date: DAYNAME(\"2017-06-15\") : Return the weekday name for a date: HOUR(\"2017-06-20 09:34:00\") : Return the hour part of a datetime: MONTH(\"2017-06-15\") : Return the month part of a date: SUBDATE(\"2017-06-15\", INTERVAL 10 DAY) : Subtract 10 days from a date and return the date WEEK(\"2017-10-25\") : Return the week number for a date: YEAR(\"2017-06-15\") : Return the year part of a date: 5.7 Some Advanced Functions 5.7.1 LISTAGG concatenates values from multiple rows into a single string. This query lists all medications in each ID, ordered by their name of medications, with the names concatenated into a single string. SELECT ID, LISTAGG(DISTINCT MEDICATIONS, &#39;, &#39;) WITHIN GROUP (ORDER BY MEDICATIONS) AS MED_ARRAY FROM table_name GROUP BY ID 5.7.2 LATERAL This SQL query involves a few advanced concepts, including the use of the LATERAL join and the FLATTEN function, which are specific to certain SQL platforms like Snowflake. Here’s a breakdown of the query: ID_ARRAY: LIST OF IDS IN EACH ROW FLATTEN function is used to “unpack” or “expand” the ID_ARRAY column into individual elements. Essentially, it takes an array and returns each element in the array as a separate row. SELECT F.MY_ID::VARCHAR AS MY_ID FROM TABLE_1 A, LATERAL FLATTEN(A.ID_ARRAY) AS F "],["adhoc-solutions.html", "Chapter 6 Adhoc solutions 6.1 Risky Projects", " Chapter 6 Adhoc solutions 6.1 Risky Projects Identify projects that are at risk for going overbudget. A project is considered to be overbudget if the cost of all employees assigned to the project is greater than the budget of the project. You’ll need to prorate the cost of the employees to the duration of the project. For example, if the budget for a project that takes half a year to complete is $10K, then the total half-year salary of all employees assigned to the project should not exceed $10K. Salary is defined on a yearly basis, so be careful how to calculate salaries for the projects that last less or more than one year. Output a list of projects that are overbudget with their project name, project budget, and prorated total employee expense (rounded to the next dollar amount). HINT: to make it simpler, consider that all years have 365 days. You don’t need to think about the leap years. Tables: linkedin_projects, linkedin_emp_projects, linkedin_employees 6.1.1 tables table: linkedin_projects id–int, title–varchar budget–int start_date–datetime end_date–datetime table: linkedin_emp_projects emp_id–int project_id– table: linkedin_employees id–int, first_name   last_name   salary–int   6.1.2 SOLUTION 1 DURATION YEAR 1 IS CALCULATED SEPARATELY WILL CAUSE PROBLEMS, BECAUSE IT IS NOT COSTLY TO KEEP IT ACCURATE TO DECIMAL POINTS WITH PROJECT_DURATION AS ( SELECT DISTINCT id, DATEDIFF(end_date, start_date)/365.0 AS DURATION_YR FROM linkedin_projects ORDER BY DURATION_YR DESC ), COST AS ( SELECT A.project_id, SUM(B.SALARY * C.DURATION_YR) AS PROJECT_COST FROM linkedin_emp_projects A INNER JOIN linkedin_employees B ON A.EMP_ID = B.ID INNER JOIN PROJECT_DURATION C ON A.project_id = C.ID GROUP BY A.project_id ) SELECT A.TITLE, A.BUDGET, CEILING(B.PROJECT_COST) AS PROJECT_COST FROM linkedin_projects A INNER JOIN COST B ON A.ID = B.project_id WHERE A.BUDGET &lt; CEILING(B.PROJECT_COST) ORDER BY TITLE ASC; 6.1.3 SOULTION 2 BETTER SOLUTION SELECT A.TITLE, A.BUDGET, CEILING(SUM(B.SALARY) * DATEDIFF(A.end_date, A.start_date) / 365.0) AS PROJECT_COST FROM linkedin_projects A LEFT JOIN linkedin_emp_projects C ON A.ID = C.project_id LEFT JOIN linkedin_employees B ON C.EMP_ID = B.ID GROUP BY A.ID HAVING A.BUDGET &lt; PROJECT_COST; "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
